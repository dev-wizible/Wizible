<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Resume Evaluation System - Enhanced</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 2rem;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
        color: white;
        padding: 3rem 2rem;
        text-align: center;
        position: relative;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        font-weight: 700;
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.9;
      }

      .main-content {
        padding: 2rem;
      }

      .section {
        margin-bottom: 3rem;
        padding: 2rem;
        border: 2px solid #f1f3f4;
        border-radius: 15px;
        transition: all 0.3s ease;
        position: relative;
      }

      .section:hover {
        border-color: #3498db;
        box-shadow: 0 5px 15px rgba(52, 152, 219, 0.1);
      }

      .section-title {
        font-size: 1.5rem;
        color: #2c3e50;
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .section-icon {
        font-size: 1.8rem;
      }

      /* Enhanced Timer Styles */
      .timer-container {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 15px;
        padding: 2rem;
        margin: 2rem 0;
        border: 2px solid #dee2e6;
        display: none;
      }

      .timer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }

      .timer-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: #2c3e50;
      }

      .timer-phase {
        padding: 0.5rem 1rem;
        background: #3498db;
        color: white;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
      }

      .timer-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
      }

      .timer-card {
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-left: 4px solid #3498db;
      }

      .timer-card.extraction {
        border-left-color: #e74c3c;
      }

      .timer-card.scoring {
        border-left-color: #27ae60;
      }

      .timer-value {
        font-size: 2.5rem;
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 0.5rem;
        font-family: 'Courier New', monospace;
      }

      .timer-label {
        font-size: 0.9rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .timer-progress {
        background: white;
        border-radius: 10px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
      }

      .progress-bar {
        width: 100%;
        height: 25px;
        background: #e9ecef;
        border-radius: 15px;
        overflow: hidden;
        margin: 1rem 0;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        transition: width 0.3s ease;
        border-radius: 15px;
        position: relative;
      }

      .progress-fill.extraction {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      .progress-fill.scoring {
        background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
      }

      .progress-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-weight: 600;
        font-size: 0.9rem;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
      }

      .eta-display {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 8px;
        margin-top: 1rem;
      }

      .eta-item {
        text-align: center;
      }

      .eta-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #3498db;
      }

      .eta-label {
        font-size: 0.8rem;
        color: #666;
        margin-top: 0.3rem;
      }

      /* Stats Grid */
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin: 1.5rem 0;
      }

      .stat-card {
        background: white;
        padding: 1.5rem;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        border: 2px solid transparent;
        position: relative;
        overflow: hidden;
      }

      .stat-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(135deg, #3498db, #2980b9);
      }

      .stat-card:hover {
        transform: translateY(-5px);
        border-color: #3498db;
        box-shadow: 0 10px 25px rgba(52, 152, 219, 0.2);
      }

      .stat-number {
        font-size: 2.5rem;
        font-weight: bold;
        color: #3498db;
        display: block;
        margin-bottom: 0.5rem;
      }

      .stat-label {
        color: #7f8c8d;
        font-weight: 500;
      }

      /* Form Styles */
      .form-group {
        margin-bottom: 1.5rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #34495e;
      }

      .form-input {
        width: 100%;
        padding: 1rem;
        border: 2px solid #e0e6ed;
        border-radius: 10px;
        font-size: 1rem;
        transition: all 0.3s ease;
        font-family: inherit;
      }

      .form-input:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
      }

      /* Button Styles */
      .btn {
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        color: white;
        border: none;
        padding: 1rem 2rem;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        position: relative;
        overflow: hidden;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
      }

      .btn:disabled {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn-success {
        background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
      }

      .btn-warning {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
      }

      .btn-danger {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      /* Performance Indicators */
      .performance-indicators {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 10px;
      }

      .performance-item {
        text-align: center;
        padding: 0.5rem;
      }

      .performance-value {
        font-size: 1.1rem;
        font-weight: bold;
        color: #2c3e50;
      }

      .performance-label {
        font-size: 0.8rem;
        color: #666;
        margin-top: 0.3rem;
      }

      /* Alerts */
      .alert {
        padding: 1rem 1.5rem;
        border-radius: 10px;
        margin: 1rem 0;
        font-weight: 500;
        position: relative;
        border-left: 4px solid transparent;
      }

      .alert-success {
        background: #d4edda;
        color: #155724;
        border-left-color: #27ae60;
      }

      .alert-error {
        background: #f8d7da;
        color: #721c24;
        border-left-color: #e74c3c;
      }

      .alert-info {
        background: #cce5ff;
        color: #004085;
        border-left-color: #3498db;
      }

      .alert-warning {
        background: #fff3cd;
        color: #856404;
        border-left-color: #f39c12;
      }

      /* Resume List Styles */
      .resume-list {
        margin-top: 2rem;
      }

      .resume-item {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 2px solid #e9ecef;
        border-radius: 15px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        transition: all 0.3s ease;
      }

      .resume-item:hover {
        border-color: #3498db;
        background: #f1f8ff;
        transform: translateX(5px);
      }

      .resume-filename {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
      }

      .resume-status {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-bottom: 1rem;
      }

      .status-badge {
        padding: 0.3rem 0.8rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }

      .status-extracted {
        background: #d4edda;
        color: #155724;
      }

      .status-scored {
        background: #cce5ff;
        color: #004085;
      }

      .status-pending {
        background: #fff3cd;
        color: #856404;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .container {
          margin: 1rem;
          border-radius: 15px;
        }

        .header {
          padding: 2rem 1rem;
        }

        .header h1 {
          font-size: 2rem;
        }

        .main-content {
          padding: 1rem;
        }

        .section {
          padding: 1.5rem;
        }

        .timer-display {
          grid-template-columns: 1fr;
        }

        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .hidden {
        display: none !important;
      }

      /* Pulsing animation for active timers */
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      .timer-active {
        animation: pulse 2s infinite;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>🤖 AI Resume Evaluation System</h1>
        <p>Extract, Configure, and Score Resumes with Advanced Timing</p>
      </div>

      <div class="main-content">
        <!-- System Statistics Section -->
        <div class="section">
          <h2 class="section-title">
            <span class="section-icon">📊</span>
            System Overview
          </h2>
          <div class="stats-grid" id="systemStats">
            <div class="stat-card">
              <span class="stat-number" id="totalProcessed">0</span>
              <div class="stat-label">Total Processed</div>
            </div>
            <div class="stat-card">
              <span class="stat-number" id="successRate">0%</span>
              <div class="stat-label">Success Rate</div>
            </div>
            <div class="stat-card">
              <span class="stat-number" id="avgProcessingTime">0s</span>
              <div class="stat-label">Avg Processing Time</div>
            </div>
            <div class="stat-card">
              <span class="stat-number" id="queueLength">0</span>
              <div class="stat-label">Queue Length</div>
            </div>
          </div>
        </div>

        <!-- Configuration Section -->
        <div class="section">
          <h2 class="section-title">
            <span class="section-icon">⚙️</span>
            Job Configuration
          </h2>
          
          <div id="configStatus" class="alert alert-warning">
            ⚠️ Please configure job description and evaluation rubric before scoring resumes
          </div>

          <div class="form-group">
            <label class="form-label" for="jobDescription">Job Description</label>
            <textarea 
              id="jobDescription" 
              class="form-input" 
              placeholder="Enter the complete job description here..."
              rows="6"
              style="min-height: 120px; resize: vertical;"
            ></textarea>
            <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
              <span id="jobDescCount">0</span>/5000 characters
            </div>
          </div>

          <div class="form-group">
            <label class="form-label" for="evaluationRubric">Evaluation Rubric</label>
            <textarea 
              id="evaluationRubric" 
              class="form-input" 
              placeholder="Enter your evaluation criteria and scoring rubric..."
              rows="8"
              style="min-height: 150px; resize: vertical;"
            ></textarea>
            <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
              <span id="rubricCount">0</span>/10000 characters
            </div>
          </div>

          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <button class="btn" onclick="saveConfiguration()" id="saveConfigBtn">
              <span class="btn-text">💾 Save Configuration</span>
            </button>
            <button class="btn btn-warning" onclick="clearConfiguration()">
              <span class="btn-text">🗑️ Clear Configuration</span>
            </button>
            <button class="btn" onclick="validateConfiguration()" id="validateBtn">
              <span class="btn-text">✅ Validate Configuration</span>
            </button>
          </div>
        </div>

        <!-- Resume Extraction Section -->
        <div class="section">
          <h2 class="section-title">
            <span class="section-icon">📄</span>
            Resume Extraction
          </h2>
          
          <div class="form-group">
            <label class="form-label">Select Resume Folder</label>
            <input type="file" id="resumeFolder" webkitdirectory directory multiple class="form-input" />
          </div>

          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <button class="btn" onclick="uploadBatch()" id="uploadBtn">
              <span class="btn-text">🚀 Process All Resumes</span>
            </button>
            <button class="btn btn-warning" onclick="pauseProcessing()" id="pauseBtn" disabled>
              <span class="btn-text">⏸️ Pause Processing</span>
            </button>
            <button class="btn btn-danger" onclick="cancelProcessing()" id="cancelBtn" disabled>
              <span class="btn-text">⏹️ Cancel Processing</span>
            </button>
          </div>

          <!-- Extraction Timer -->
          <div class="timer-container" id="extractionTimer">
            <div class="timer-header">
              <div class="timer-title">📄 Resume Extraction Progress</div>
              <div class="timer-phase" id="extractionPhase">Extracting</div>
            </div>
            
            <div class="timer-display">
              <div class="timer-card extraction">
                <div class="timer-value" id="extractionElapsed">00:00:00</div>
                <div class="timer-label">Elapsed Time</div>
              </div>
              <div class="timer-card extraction">
                <div class="timer-value" id="extractionETA">--:--:--</div>
                <div class="timer-label">Estimated Completion</div>
              </div>
              <div class="timer-card extraction">
                <div class="timer-value" id="extractionSpeed">0</div>
                <div class="timer-label">Files/Minute</div>
              </div>
            </div>

            <div class="timer-progress">
              <div class="progress-bar">
                <div class="progress-fill extraction" id="extractionProgressFill" style="width: 0%">
                  <div class="progress-text" id="extractionProgressText">0%</div>
                </div>
              </div>
              
              <div class="eta-display">
                <div class="eta-item">
                  <div class="eta-value" id="extractionProcessed">0</div>
                  <div class="eta-label">Processed</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="extractionTotal">0</div>
                  <div class="eta-label">Total Files</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="extractionSuccess">0</div>
                  <div class="eta-label">Successful</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="extractionErrors">0</div>
                  <div class="eta-label">Errors</div>
                </div>
              </div>
            </div>

            <div class="performance-indicators">
              <div class="performance-item">
                <div class="performance-value" id="extractionAvgTime">0s</div>
                <div class="performance-label">Avg per File</div>
              </div>
              <div class="performance-item">
                <div class="performance-value" id="extractionRemaining">0</div>
                <div class="performance-label">Remaining</div>
              </div>
              <div class="performance-item">
                <div class="performance-value" id="extractionEfficiency">0%</div>
                <div class="performance-label">Efficiency</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Resume Scoring Section -->
        <div class="section">
          <h2 class="section-title">
            <span class="section-icon">🎯</span>
            AI Resume Scoring
          </h2>
          
          <div style="display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap;">
            <button class="btn" onclick="loadAvailableResumes()">
              <span class="btn-text">🔄 Refresh Resume List</span>
            </button>
            <button class="btn btn-success" onclick="scoreAllResumes()" id="scoreAllBtn">
              <span class="btn-text">⚡ Score All Resumes</span>
            </button>
            <button class="btn" onclick="exportResults()">
              <span class="btn-text">📊 Export Results</span>
            </button>
          </div>

          <!-- Scoring Timer -->
          <div class="timer-container" id="scoringTimer">
            <div class="timer-header">
              <div class="timer-title">🎯 AI Scoring Progress</div>
              <div class="timer-phase" id="scoringPhase">Scoring</div>
            </div>
            
            <div class="timer-display">
              <div class="timer-card scoring">
                <div class="timer-value" id="scoringElapsed">00:00:00</div>
                <div class="timer-label">Elapsed Time</div>
              </div>
              <div class="timer-card scoring">
                <div class="timer-value" id="scoringETA">--:--:--</div>
                <div class="timer-label">Estimated Completion</div>
              </div>
              <div class="timer-card scoring">
                <div class="timer-value" id="scoringSpeed">0</div>
                <div class="timer-label">Scores/Minute</div>
              </div>
            </div>

            <div class="timer-progress">
              <div class="progress-bar">
                <div class="progress-fill scoring" id="scoringProgressFill" style="width: 0%">
                  <div class="progress-text" id="scoringProgressText">0%</div>
                </div>
              </div>
              
              <div class="eta-display">
                <div class="eta-item">
                  <div class="eta-value" id="scoringProcessed">0</div>
                  <div class="eta-label">Scored</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="scoringTotal">0</div>
                  <div class="eta-label">Total Files</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="scoringSuccess">0</div>
                  <div class="eta-label">Successful</div>
                </div>
                <div class="eta-item">
                  <div class="eta-value" id="scoringErrors">0</div>
                  <div class="eta-label">Errors</div>
                </div>
              </div>
            </div>

            <div class="performance-indicators">
              <div class="performance-item">
                <div class="performance-value" id="scoringAvgTime">0s</div>
                <div class="performance-label">Avg per Score</div>
              </div>
              <div class="performance-item">
                <div class="performance-value" id="scoringRemaining">0</div>
                <div class="performance-label">Remaining</div>
              </div>
              <div class="performance-item">
                <div class="performance-value" id="scoringEfficiency">0%</div>
                <div class="performance-label">Success Rate</div>
              </div>
            </div>
          </div>

          <div id="resumesList" class="resume-list">
            <div class="alert alert-info">
              Click "Refresh Resume List" to load available resumes for scoring
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Enhanced timer management
      const TimerManager = {
        extraction: {
          startTime: null,
          isActive: false,
          intervalId: null,
          data: { total: 0, processed: 0, success: 0, errors: 0 }
        },
        scoring: {
          startTime: null,
          isActive: false,
          intervalId: null,
          data: { total: 0, processed: 0, success: 0, errors: 0 }
        }
      };

      // Global state
      let processingCancelled = false;
      let currentBatchId = null;
      let configurationSaved = false;

      // Configuration management functions
      async function saveConfiguration() {
        const jobDescription = document.getElementById('jobDescription').value.trim();
        const evaluationRubric = document.getElementById('evaluationRubric').value.trim();
        const saveBtn = document.getElementById('saveConfigBtn');

        if (!jobDescription || jobDescription.length < 10) {
          showAlert('Job description must be at least 10 characters long', 'error');
          return;
        }

        if (!evaluationRubric || evaluationRubric.length < 10) {
          showAlert('Evaluation rubric must be at least 10 characters long', 'error');
          return;
        }

        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="btn-text">💾 Saving...</span>';

        try {
          const response = await fetch('http://localhost:3000/api/upload-config', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              jobDescription,
              evaluationRubric
            })
          });

          const data = await response.json();

          if (response.ok) {
            configurationSaved = true;
            updateConfigStatus(true);
            showAlert('✅ Configuration saved successfully!', 'success');
          } else {
            throw new Error(data.error || 'Failed to save configuration');
          }
        } catch (error) {
          showAlert(`❌ Error saving configuration: ${error.message}`, 'error');
        } finally {
          saveBtn.disabled = false;
          saveBtn.innerHTML = '<span class="btn-text">💾 Save Configuration</span>';
        }
      }

      async function validateConfiguration() {
        const jobDescription = document.getElementById('jobDescription').value.trim();
        const evaluationRubric = document.getElementById('evaluationRubric').value.trim();
        const validateBtn = document.getElementById('validateBtn');

        if (!jobDescription || !evaluationRubric) {
          showAlert('⚠️ Please enter both job description and evaluation rubric', 'warning');
          return;
        }

        validateBtn.disabled = true;
        validateBtn.innerHTML = '<span class="btn-text">✅ Validating...</span>';

        try {
          // Simple validation checks
          const issues = [];
          const warnings = [];

          if (jobDescription.length < 50) {
            warnings.push('Job description is quite short');
          }

          if (evaluationRubric.length < 100) {
            warnings.push('Evaluation rubric could be more detailed');
          }

          if (!jobDescription.toLowerCase().includes('requirements')) {
            warnings.push('Job description might be missing requirements section');
          }

          if (!evaluationRubric.toLowerCase().includes('score')) {
            warnings.push('Evaluation rubric might be missing scoring criteria');
          }

          let message = '✅ Configuration validation completed';
          let type = 'success';

          if (issues.length > 0) {
            message = `❌ Validation failed: ${issues.join(', ')}`;
            type = 'error';
          } else if (warnings.length > 0) {
            message = `⚠️ Validation passed with warnings: ${warnings.join(', ')}`;
            type = 'warning';
          }

          showAlert(message, type);

        } finally {
          validateBtn.disabled = false;
          validateBtn.innerHTML = '<span class="btn-text">✅ Validate Configuration</span>';
        }
      }

      async function clearConfiguration() {
        try {
          const response = await fetch('http://localhost:3000/api/config', {
            method: 'DELETE'
          });

          if (response.ok) {
            configurationSaved = false;
            updateConfigStatus(false);
            document.getElementById('jobDescription').value = '';
            document.getElementById('evaluationRubric').value = '';
            updateCharacterCounts();
            showAlert('🗑️ Configuration cleared', 'info');
          }
        } catch (error) {
          showAlert(`❌ Error clearing configuration: ${error.message}`, 'error');
        }
      }

      function updateConfigStatus(hasConfig) {
        const statusEl = document.getElementById('configStatus');
        if (hasConfig) {
          statusEl.className = 'alert alert-success';
          statusEl.innerHTML = '✅ Configuration saved and ready for scoring';
        } else {
          statusEl.className = 'alert alert-warning';
          statusEl.innerHTML = '⚠️ Please configure job description and evaluation rubric before scoring resumes';
        }
      }

      function setupCharacterCounters() {
        const jobDesc = document.getElementById('jobDescription');
        const rubric = document.getElementById('evaluationRubric');
        const jobDescCount = document.getElementById('jobDescCount');
        const rubricCount = document.getElementById('rubricCount');

        jobDesc.addEventListener('input', updateCharacterCounts);
        rubric.addEventListener('input', updateCharacterCounts);
      }

      function updateCharacterCounts() {
        const jobDesc = document.getElementById('jobDescription');
        const rubric = document.getElementById('evaluationRubric');
        const jobDescCount = document.getElementById('jobDescCount');
        const rubricCount = document.getElementById('rubricCount');

        jobDescCount.textContent = jobDesc.value.length;
        rubricCount.textContent = rubric.value.length;

        // Update colors based on length
        jobDescCount.style.color = jobDesc.value.length > 4500 ? '#e74c3c' : '#666';
        rubricCount.style.color = rubric.value.length > 9000 ? '#e74c3c' : '#666';
      }

      // Check configuration on page load
      async function checkConfiguration() {
        try {
          const response = await fetch('http://localhost:3000/api/config');
          const data = await response.json();
          
          if (response.ok && data.hasConfig) {
            configurationSaved = true;
            updateConfigStatus(true);
          }
        } catch (error) {
          console.log('No existing configuration found');
        }
      }

      // Timer utility functions
      function formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }

      function calculateETA(processed, total, elapsedTime) {
        if (processed === 0) return '--:--:--';
        
        const avgTimePerItem = elapsedTime / processed;
        const remainingItems = total - processed;
        const estimatedRemainingTime = remainingItems * avgTimePerItem;
        
        return formatTime(estimatedRemainingTime);
      }

      function calculateSpeed(processed, elapsedTime) {
        if (elapsedTime === 0) return 0;
        return Math.round((processed / elapsedTime) * 60000); // items per minute
      }

      // Start timer for extraction
      function startExtractionTimer(total) {
        TimerManager.extraction.startTime = Date.now();
        TimerManager.extraction.isActive = true;
        TimerManager.extraction.data = { total, processed: 0, success: 0, errors: 0 };
        
        document.getElementById('extractionTimer').style.display = 'block';
        document.getElementById('extractionTotal').textContent = total;
        
        TimerManager.extraction.intervalId = setInterval(() => {
          updateExtractionTimer();
        }, 1000);
      }

      function updateExtractionTimer() {
        if (!TimerManager.extraction.isActive) return;
        
        const elapsed = Date.now() - TimerManager.extraction.startTime;
        const data = TimerManager.extraction.data;
        
        // Update elapsed time
        document.getElementById('extractionElapsed').textContent = formatTime(elapsed);
        
        // Update progress
        const percentage = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;
        document.getElementById('extractionProgressFill').style.width = percentage + '%';
        document.getElementById('extractionProgressText').textContent = percentage + '%';
        
        // Update counters
        document.getElementById('extractionProcessed').textContent = data.processed;
        document.getElementById('extractionSuccess').textContent = data.success;
        document.getElementById('extractionErrors').textContent = data.errors;
        
        // Update performance metrics
        const speed = calculateSpeed(data.processed, elapsed);
        document.getElementById('extractionSpeed').textContent = speed;
        
        const avgTime = data.processed > 0 ? elapsed / data.processed : 0;
        document.getElementById('extractionAvgTime').textContent = Math.round(avgTime / 1000) + 's';
        
        const remaining = data.total - data.processed;
        document.getElementById('extractionRemaining').textContent = remaining;
        
        const efficiency = data.processed > 0 ? Math.round((data.success / data.processed) * 100) : 0;
        document.getElementById('extractionEfficiency').textContent = efficiency + '%';
        
        // Update ETA
        document.getElementById('extractionETA').textContent = calculateETA(data.processed, data.total, elapsed);
      }

      function stopExtractionTimer() {
        TimerManager.extraction.isActive = false;
        if (TimerManager.extraction.intervalId) {
          clearInterval(TimerManager.extraction.intervalId);
        }
        document.getElementById('extractionPhase').textContent = 'Completed';
      }

      // Start timer for scoring
      function startScoringTimer(total) {
        TimerManager.scoring.startTime = Date.now();
        TimerManager.scoring.isActive = true;
        TimerManager.scoring.data = { total, processed: 0, success: 0, errors: 0 };
        
        document.getElementById('scoringTimer').style.display = 'block';
        document.getElementById('scoringTotal').textContent = total;
        
        TimerManager.scoring.intervalId = setInterval(() => {
          updateScoringTimer();
        }, 1000);
      }

      function updateScoringTimer() {
        if (!TimerManager.scoring.isActive) return;
        
        const elapsed = Date.now() - TimerManager.scoring.startTime;
        const data = TimerManager.scoring.data;
        
        // Update elapsed time
        document.getElementById('scoringElapsed').textContent = formatTime(elapsed);
        
        // Update progress
        const percentage = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;
        document.getElementById('scoringProgressFill').style.width = percentage + '%';
        document.getElementById('scoringProgressText').textContent = percentage + '%';
        
        // Update counters
        document.getElementById('scoringProcessed').textContent = data.processed;
        document.getElementById('scoringSuccess').textContent = data.success;
        document.getElementById('scoringErrors').textContent = data.errors;
        
        // Update performance metrics
        const speed = calculateSpeed(data.processed, elapsed);
        document.getElementById('scoringSpeed').textContent = speed;
        
        const avgTime = data.processed > 0 ? elapsed / data.processed : 0;
        document.getElementById('scoringAvgTime').textContent = Math.round(avgTime / 1000) + 's';
        
        const remaining = data.total - data.processed;
        document.getElementById('scoringRemaining').textContent = remaining;
        
        const efficiency = data.processed > 0 ? Math.round((data.success / data.processed) * 100) : 0;
        document.getElementById('scoringEfficiency').textContent = efficiency + '%';
        
        // Update ETA
        document.getElementById('scoringETA').textContent = calculateETA(data.processed, data.total, elapsed);
      }

      function stopScoringTimer() {
        TimerManager.scoring.isActive = false;
        if (TimerManager.scoring.intervalId) {
          clearInterval(TimerManager.scoring.intervalId);
        }
        document.getElementById('scoringPhase').textContent = 'Completed';
      }

      // Update timer data
      function updateExtractionProgress(processed, total, success, errors) {
        TimerManager.extraction.data = { total, processed, success, errors };
      }

      function updateScoringProgress(processed, total, success, errors) {
        TimerManager.scoring.data = { total, processed, success, errors };
      }

      // Main processing functions
      async function uploadBatch() {
        const folderInput = document.getElementById('resumeFolder');
        const uploadBtn = document.getElementById('uploadBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        if (!folderInput.files.length) {
          showAlert('Please select a folder containing resume files.', 'error');
          return;
        }

        const allFiles = Array.from(folderInput.files);
        const pdfFiles = allFiles.filter(file => 
          file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
        );

        if (pdfFiles.length === 0) {
          showAlert('No PDF files found in the selected folder.', 'error');
          return;
        }

        processingCancelled = false;
        uploadBtn.disabled = true;
        pauseBtn.disabled = false;
        cancelBtn.disabled = false;

        // Start extraction timer
        startExtractionTimer(pdfFiles.length);
        showAlert(`Starting extraction of ${pdfFiles.length} resumes...`, 'info');

        const formData = new FormData();
        pdfFiles.forEach(file => formData.append('resumes', file));

        try {
          const response = await fetch('http://localhost:3000/api/batch-extract', {
            method: 'POST',
            body: formData
          });

          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }

          const data = await response.json();
          currentBatchId = data.batchId;
          showAlert(`Batch extraction started with ID: ${currentBatchId}`, 'success');

          await pollExtractionProgress(currentBatchId);

        } catch (error) {
          stopExtractionTimer();
          showAlert(`Error starting batch extraction: ${error.message}`, 'error');
        } finally {
          uploadBtn.disabled = false;
          pauseBtn.disabled = true;
          cancelBtn.disabled = true;
        }
      }

      async function pollExtractionProgress(batchId) {
        while (!processingCancelled && TimerManager.extraction.isActive) {
          try {
            const response = await fetch(`http://localhost:3000/api/batch-progress/${batchId}`);
            const data = await response.json();

            updateExtractionProgress(data.processed, data.total, data.success, data.errors);

            if (data.status === 'completed') {
              stopExtractionTimer();
              showAlert('✅ Resume extraction completed!', 'success');
              showAlert(`📊 Results: ${data.success} successful, ${data.errors} errors`, 'info');
              loadAvailableResumes();
              break;
            } else if (data.status === 'failed') {
              stopExtractionTimer();
              showAlert('❌ Batch extraction failed', 'error');
              break;
            }

            await new Promise(resolve => setTimeout(resolve, 2000));
          } catch (error) {
            showAlert(`Error polling extraction progress: ${error.message}`, 'error');
            await new Promise(resolve => setTimeout(resolve, 5000));
          }
        }
      }

      async function scoreAllResumes() {
        // Check if configuration is saved before scoring
        if (!configurationSaved) {
          showAlert('⚠️ Please save configuration before scoring resumes', 'error');
          return;
        }

        try {
          const response = await fetch('http://localhost:3000/api/available-resumes');
          const data = await response.json();
          
          const filenames = data.resumes.map(r => r.filename);
          
          if (filenames.length === 0) {
            showAlert('No resumes available for scoring', 'error');
            return;
          }

          const scoreAllBtn = document.getElementById('scoreAllBtn');
          scoreAllBtn.disabled = true;

          // Start scoring timer
          startScoringTimer(filenames.length);
          showAlert(`🎯 Starting AI scoring of ${filenames.length} resumes...`, 'info');

          // Poll scoring progress
          await pollScoringProgress(filenames);

        } catch (error) {
          stopScoringTimer();
          showAlert(`Error in batch scoring: ${error.message}`, 'error');
        } finally {
          const scoreAllBtn = document.getElementById('scoreAllBtn');
          scoreAllBtn.disabled = false;
        }
      }

      async function pollScoringProgress(filenames) {
        let completed = 0;
        let successful = 0;
        let errors = 0;

        // Process files in batches to simulate realistic scoring
        const batchSize = 5;
        for (let i = 0; i < filenames.length; i += batchSize) {
          if (processingCancelled) break;

          const batch = filenames.slice(i, i + batchSize);
          
          try {
            const response = await fetch('http://localhost:3000/api/score-batch', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ filenames: batch })
            });

            const batchData = await response.json();
            
            if (response.ok) {
              completed += batch.length;
              successful += batchData.summary.successful;
              errors += batchData.summary.failed;
              
              updateScoringProgress(completed, filenames.length, successful, errors);
              
              // Small delay between batches
              await new Promise(resolve => setTimeout(resolve, 1000));
            } else {
              throw new Error(batchData.error || 'Batch scoring failed');
            }

          } catch (error) {
            errors += batch.length;
            completed += batch.length;
            updateScoringProgress(completed, filenames.length, successful, errors);
            console.error(`Error scoring batch:`, error);
          }
        }

        stopScoringTimer();
        showAlert(`🎉 AI scoring completed! ${successful} successful, ${errors} errors`, 'success');
        loadAvailableResumes();
      }

      async function loadAvailableResumes() {
        const resumesList = document.getElementById('resumesList');
        
        resumesList.innerHTML = '<div class="alert alert-info">Loading resumes...</div>';

        try {
          const response = await fetch('http://localhost:3000/api/available-resumes');
          const data = await response.json();

          if (data.resumes.length === 0) {
            resumesList.innerHTML = `
              <div class="alert alert-info">
                <strong>No extracted resumes found.</strong><br>
                Please extract resumes first using the section above.
              </div>
            `;
            return;
          }

          resumesList.innerHTML = data.resumes.map(resume => createResumeItem(resume)).join('');
          
          showAlert(`📋 Loaded ${data.resumes.length} resumes (${data.scored} already scored)`, 'info');

        } catch (error) {
          resumesList.innerHTML = `
            <div class="alert alert-error">
              <strong>Error loading resumes:</strong> ${error.message}
            </div>
          `;
        }
      }

      function createResumeItem(resume) {
        const hasScores = resume.hasScores;
        
        return `
          <div class="resume-item">
            <div class="resume-filename">${resume.filename}</div>
            <div class="resume-status">
              <span class="status-badge status-extracted">
                <span>✅</span> Extracted
              </span>
              ${hasScores 
                ? '<span class="status-badge status-scored"><span>🎯</span> Scored</span>' 
                : '<span class="status-badge status-pending"><span>⏳</span> Not Scored</span>'
              }
            </div>
          </div>
        `;
      }

      function pauseProcessing() {
        // Implementation for pause functionality
        showAlert('⏸️ Processing paused', 'warning');
      }

      function cancelProcessing() {
        processingCancelled = true;
        if (currentBatchId) {
          fetch(`http://localhost:3000/api/batch-cancel/${currentBatchId}`, {
            method: 'POST'
          });
        }
        
        // Stop all timers
        stopExtractionTimer();
        stopScoringTimer();
        
        showAlert('🛑 Processing cancelled by user', 'warning');
      }

      function exportResults() {
        showAlert('📊 Export functionality coming soon!', 'info');
      }

      function showAlert(message, type) {
        // Remove existing alerts
        const existingAlerts = document.querySelectorAll('.alert.temp-alert');
        existingAlerts.forEach(alert => alert.remove());

        // Create new alert
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} temp-alert`;
        alert.innerHTML = message;
        
        // Insert at top of main content
        const mainContent = document.querySelector('.main-content');
        mainContent.insertBefore(alert, mainContent.firstChild);

        // Auto-remove after 5 seconds for non-error alerts
        if (type !== 'error') {
          setTimeout(() => {
            if (alert.parentNode) {
              alert.remove();
            }
          }, 5000);
        }

        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', function() {
        // Setup character counters for textareas
        setupCharacterCounters();
        
        // Check for existing configuration
        checkConfiguration();
        
        // Load available resumes
        loadAvailableResumes();
        
        // Initialize character counts
        updateCharacterCounts();
        
        showAlert('🚀 System ready - Enhanced with advanced timing and configuration!', 'success');
      });
    </script>
  </body>
</html>