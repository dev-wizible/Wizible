<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Resume Processor - Complete Workflow</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        color: #333;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 3rem;
        font-weight: 700;
        margin-bottom: 10px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.9;
        font-weight: 400;
      }

      .workflow-container {
        display: grid;
        gap: 30px;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        margin-bottom: 30px;
      }

      .step-card {
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .step-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 30px 60px rgba(0, 0, 0, 0.15);
      }

      .step-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 5px;
        background: linear-gradient(90deg, #667eea, #764ba2);
      }

      .step-header {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
      }

      .step-number {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        margin-right: 15px;
        font-size: 1.1rem;
      }

      .step-title {
        font-size: 1.4rem;
        font-weight: 600;
        color: #2c3e50;
      }

      .step-content {
        margin-bottom: 25px;
      }

      .step-description {
        color: #666;
        line-height: 1.6;
        margin-bottom: 20px;
      }

      /* Step 1: Upload Files */
      .file-upload-area {
        border: 3px dashed #ddd;
        border-radius: 15px;
        padding: 40px 20px;
        text-align: center;
        transition: all 0.3s ease;
        cursor: pointer;
        background: #fafafa;
        position: relative;
      }

      .file-upload-area:hover {
        border-color: #667eea;
        background: #f0f4ff;
      }

      .file-upload-area.dragover {
        border-color: #4caf50;
        background: #e8f5e9;
        transform: scale(1.02);
      }

      .upload-icon {
        font-size: 3rem;
        color: #667eea;
        margin-bottom: 15px;
      }

      .upload-text {
        font-size: 1.2rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
      }

      .upload-hint {
        color: #666;
        font-size: 0.9rem;
      }

      .file-input {
        display: none;
      }

      .file-list {
        margin-top: 20px;
        max-height: 200px;
        overflow-y: auto;
        background: #f8f9fa;
        border-radius: 10px;
        padding: 15px;
      }

      .file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #eee;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-name {
        font-weight: 500;
        color: #333;
      }

      .file-size {
        color: #666;
        font-size: 0.85rem;
      }

      /* Buttons */
      .btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 1rem;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        text-decoration: none;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
      }

      .btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn-success {
        background: linear-gradient(135deg, #4caf50, #45a049);
      }

      .btn-success:hover {
        box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
      }

      .btn-warning {
        background: linear-gradient(135deg, #ff9800, #f57c00);
      }

      .btn-danger {
        background: linear-gradient(135deg, #f44336, #d32f2f);
      }

      /* Form Elements */
      .form-group {
        margin-bottom: 20px;
      }

      .form-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
      }

      .form-textarea {
        width: 100%;
        padding: 15px;
        border: 2px solid #e1e5e9;
        border-radius: 10px;
        font-family: inherit;
        font-size: 0.95rem;
        resize: vertical;
        transition: border-color 0.3s ease;
      }

      .form-textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      /* Progress Section */
      .progress-section {
        display: none;
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        margin-top: 30px;
      }

      .progress-header {
        text-align: center;
        margin-bottom: 30px;
      }

      .progress-title {
        font-size: 1.8rem;
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 10px;
      }

      .batch-id {
        color: #666;
        font-family: monospace;
        background: #f8f9fa;
        padding: 5px 10px;
        border-radius: 5px;
        display: inline-block;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .metric-card {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        border-left: 4px solid #667eea;
      }

      .metric-value {
        font-size: 2rem;
        font-weight: 700;
        color: #2c3e50;
        font-family: monospace;
      }

      .metric-label {
        color: #666;
        font-size: 0.85rem;
        margin-top: 5px;
        text-transform: uppercase;
        font-weight: 500;
      }

      .progress-bar {
        width: 100%;
        height: 12px;
        background: #e9ecef;
        border-radius: 6px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        transition: width 0.3s ease;
        border-radius: 6px;
      }

      .progress-fill.success {
        background: linear-gradient(90deg, #4caf50, #45a049);
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      /* Status Log */
      .status-log {
        background: #2c3e50;
        color: #ecf0f1;
        border-radius: 10px;
        height: 250px;
        overflow-y: auto;
        padding: 20px;
        font-family: "Courier New", monospace;
        font-size: 0.85rem;
        line-height: 1.4;
        margin: 20px 0;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 4px 0;
      }

      .log-entry.success {
        color: #2ecc71;
      }
      .log-entry.error {
        color: #e74c3c;
      }
      .log-entry.info {
        color: #3498db;
      }
      .log-entry.warning {
        color: #f39c12;
      }

      /* Results Section */
      .results-section {
        display: none;
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        border: 2px solid #28a745;
        border-radius: 20px;
        padding: 30px;
        margin-top: 30px;
        text-align: center;
      }

      .results-title {
        font-size: 1.8rem;
        font-weight: 600;
        color: #155724;
        margin-bottom: 15px;
      }

      .results-description {
        color: #155724;
        margin-bottom: 25px;
      }

      .results-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
      }

      /* Button groups for download actions */
      .step-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .step-actions .btn {
        flex: 1;
        min-width: 150px;
      }

      /* Hidden class */
      .hidden {
        display: none !important;
      }

      /* Conversion Progress Styles */
      .conversion-progress {
        background: #f8f9fa;
        border: 2px solid #007bff;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
      }

      .conversion-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .conversion-header h4 {
        color: #007bff;
        margin: 0;
        font-size: 1.1rem;
      }

      .conversion-counter {
        font-weight: 600;
        color: #333;
        font-size: 1rem;
      }

      .conversion-stats {
        display: flex;
        gap: 20px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .stat-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .stat-label {
        color: #666;
        font-size: 0.9rem;
      }

      .stat-value {
        font-weight: 600;
        color: #333;
        font-family: monospace;
      }

      /* Extraction Complete Styles */
      .extraction-complete,
      .evaluation-complete {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        border: 2px solid #28a745;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        text-align: center;
      }

      .complete-header h4 {
        color: #155724;
        margin: 0 0 10px 0;
        font-size: 1.1rem;
      }

      .complete-summary {
        color: #155724;
        font-weight: 500;
        margin-bottom: 15px;
      }

      /* Detected Files Styles */
      .detected-files {
        background: #f8f9fa;
        border: 2px solid #007bff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .detected-header h4 {
        color: #007bff;
        margin: 0 0 10px 0;
        font-size: 1.1rem;
      }

      .detected-count {
        color: #333;
        font-weight: 500;
        margin-bottom: 15px;
      }

      .detected-list {
        max-height: 150px;
        overflow-y: auto;
        background: white;
        border-radius: 8px;
        padding: 10px;
      }

      .detected-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #eee;
      }

      .detected-item:last-child {
        border-bottom: none;
      }

      .detected-name {
        font-weight: 500;
        color: #333;
      }

      .detected-size {
        color: #666;
        font-size: 0.85rem;
      }

      /* Ready Section Styles */
      .ready-section {
        background: #e8f5e9;
        border: 2px solid #4caf50;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .ready-status p {
        margin: 8px 0;
        font-size: 1rem;
      }

      /* Evaluation Progress Styles */
      .evaluation-progress {
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .eval-header h4 {
        color: #856404;
        margin: 0 0 10px 0;
        font-size: 1.1rem;
      }

      .eval-counter {
        color: #333;
        font-weight: 600;
        margin-bottom: 15px;
      }

      .eval-stats {
        display: flex;
        gap: 20px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      /* Animation for evaluation buttons */
      .btn.evaluating {
        background: linear-gradient(135deg, #ffc107, #e0a800);
        animation: pulse 1.5s ease-in-out infinite;
      }

      /* Step completion indicators */
      .step-card.completed {
        border-left-color: #28a745 !important;
        background: linear-gradient(135deg, #f8fff9, #e8f5e9);
      }

      .step-card.processing {
        border-left-color: #ffc107 !important;
        background: linear-gradient(135deg, #fffbf0, #fff3cd);
      }

      /* Status indicators */
      .status-active {
        border-left-color: #4caf50 !important;
      }

      .status-completed {
        border-left-color: #2196f3 !important;
      }

      .status-pending {
        border-left-color: #ff9800 !important;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .container {
          padding: 15px;
        }

        .workflow-container {
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .header h1 {
          font-size: 2.2rem;
        }

        .metrics-grid {
          grid-template-columns: repeat(2, 1fr);
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        .results-buttons {
          flex-direction: column;
          align-items: center;
        }

        .step-actions {
          flex-direction: column;
        }
        .step-actions .btn {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ Resume Processor</h1>
        <p>Complete workflow for processing up to 5,000 resumes with AI</p>
        
        <!-- Extraction Mode Switcher -->
        <div class="extraction-mode-switcher" style="margin-top: 15px; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
          <label for="extractionMode" style="margin-right: 10px; color: #495057; font-weight: 500; font-size: 14px;">Extraction Folder:</label>
          <select id="extractionMode" style="padding: 6px 12px; border: 1px solid #ced4da; border-radius: 4px; background: white; font-size: 14px; color: #495057;">
            <option value="main">Main (extractions/)</option>
            <option value="test">Test (extractions-test/)</option>
          </select>
          <span id="extractionModeStatus" style="margin-left: 10px; font-size: 12px; font-weight: 500;"></span>
        </div>
      </div>

      <div class="workflow-container">
        <!-- Step 1: Upload & Convert Resumes -->
        <div class="step-card" id="step1">
          <div class="step-header">
            <div class="step-number">1</div>
            <div class="step-title">Upload & Convert</div>
          </div>
          <div class="step-content">
            <div class="step-description">
              Upload PDF resume files and convert them to structured JSON using
              LlamaIndex.
            </div>
            <div class="file-upload-area" id="fileUploadArea">
              <div class="upload-icon">üìÅ</div>
              <div class="upload-text">
                Drop PDF files here or click to browse
              </div>
              <div class="upload-hint">Maximum 5,000 files ‚Ä¢ 10MB per file</div>
              <input
                type="file"
                id="fileInput"
                class="file-input"
                multiple
                accept=".pdf"
              />
            </div>
            <div id="fileList" class="file-list hidden"></div>

            <!-- Conversion Progress -->
            <div id="conversionProgress" class="conversion-progress hidden">
              <div class="conversion-header">
                <h4>üîÑ Converting to JSON...</h4>
                <div class="conversion-counter">
                  <span id="convertedCount">0</span> /
                  <span id="totalToConvert">0</span> files converted
                </div>
              </div>
              <div class="progress-bar">
                <div
                  id="conversionProgressFill"
                  class="progress-fill"
                  style="width: 0%"
                ></div>
              </div>
              <div class="conversion-stats">
                <div class="stat-item">
                  <span class="stat-label">Success:</span>
                  <span id="conversionSuccess" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Failed:</span>
                  <span id="conversionFailed" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Rate:</span>
                  <span id="conversionRate" class="stat-value">0/min</span>
                </div>
              </div>
            </div>

            <!-- Extraction Complete Section -->
            <div id="extractionComplete" class="extraction-complete hidden">
              <div class="complete-header">
                <h4>‚úÖ Extraction Complete!</h4>
                <div class="complete-summary">
                  <span id="extractedSummary"
                    >0 files extracted successfully</span
                  >
                </div>
              </div>
              <button id="downloadExtractions" class="btn">
                <span>üì•</span>
                Download Extracted JSONs
              </button>
            </div>
          </div>
          <div class="step-actions">
            <button id="convertToJson" class="btn" disabled>
              <span>üîÑ</span>
              Convert to JSON
            </button>
            <button
              id="downloadExtractionsAlways"
              class="btn btn-success"
              disabled
            >
              <span>üì•</span>
              Download JSON Files
            </button>
          </div>
        </div>

        <!-- Step 2: Configure Job -->
        <div class="step-card status-pending" id="step2">
          <div class="step-header">
            <div class="step-number">2</div>
            <div class="step-title">Configure Job</div>
          </div>
          <div class="step-content">
            <div class="step-description">
              Provide job description and evaluation criteria for AI scoring.
            </div>
            <div class="form-group">
              <label class="form-label">Job Description</label>
              <textarea
                id="jobDescription"
                class="form-textarea"
                rows="4"
                placeholder="Enter the complete job description..."
              ></textarea>
            </div>
            <div class="form-group">
              <label class="form-label">Evaluation Rubric</label>
              <textarea
                id="evaluationRubric"
                class="form-textarea"
                rows="4"
                placeholder="Enter evaluation criteria and scoring methodology..."
              ></textarea>
            </div>
          </div>
          <button id="saveConfig" class="btn" disabled>
            <span>üíæ</span>
            Save Configuration
          </button>
        </div>

        <!-- Step 3: Review & Start -->
        <div class="step-card status-pending" id="step3">
          <div class="step-header">
            <div class="step-number">3</div>
            <div class="step-title">Review & Start</div>
          </div>
          <div class="step-content">
            <div class="step-description">
              Review extracted JSON files and start the AI evaluation pipeline.
            </div>

            <!-- Auto-detected Files -->
            <div id="detectedFiles" class="detected-files hidden">
              <div class="detected-header">
                <h4>üìã Detected Extracted Files</h4>
                <div class="detected-count">
                  Found <span id="detectedCount">0</span> JSON files ready for
                  evaluation
                </div>
              </div>
              <div id="detectedFilesList" class="detected-list"></div>
            </div>

            <div id="readyToStart" class="ready-section hidden">
              <div class="ready-status">
                <p>
                  <strong>‚úÖ Extraction:</strong>
                  <span id="readyExtracted">0</span> files
                </p>
                <p>
                  <strong>‚öôÔ∏è Configuration:</strong>
                  <span id="readyConfig">Not set</span>
                </p>
                <p>
                  <strong>üöÄ Ready to evaluate:</strong>
                  <span id="readyToEvaluate">0</span> files
                </p>
              </div>
            </div>
          </div>
          <button id="startEvaluation" class="btn btn-success" disabled>
            <span>üöÄ</span>
            Start Evaluation
          </button>
        </div>

        <!-- Step 4: OpenAI Evaluation -->
        <div class="step-card status-pending" id="step4">
          <div class="step-header">
            <div class="step-number">4</div>
            <div class="step-title">OpenAI Evaluation</div>
          </div>
          <div class="step-content">
            <div class="step-description">
              AI scoring using OpenAI GPT-4o-mini with 15 criteria evaluation.
            </div>

            <!-- Scoring Progress -->
            <div id="scoringProgress" class="evaluation-progress hidden">
              <div class="eval-header">
                <h4>ü§ñ OpenAI Scoring in Progress...</h4>
                <div class="eval-counter">
                  <span id="scoredCount">0</span> /
                  <span id="totalToScore">0</span> files scored
                </div>
              </div>
              <div class="progress-bar">
                <div
                  id="scoringProgressFill"
                  class="progress-fill"
                  style="width: 0%"
                ></div>
              </div>
              <div class="eval-stats">
                <div class="stat-item">
                  <span class="stat-label">Completed:</span>
                  <span id="scoringCompleted" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Failed:</span>
                  <span id="scoringFailed" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Avg Score:</span>
                  <span id="avgScore" class="stat-value">-</span>
                </div>
              </div>
            </div>

            <!-- Scoring Complete -->
            <div id="scoringComplete" class="evaluation-complete hidden">
              <div class="complete-header">
                <h4>üéØ OpenAI Scoring Complete!</h4>
                <div class="complete-summary">
                  <span id="scoringSummary">0 files scored successfully</span>
                </div>
              </div>
              <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button id="downloadScores" class="btn btn-success">
                  <span>üì•</span>
                  Download AI Scores
                </button>
                <button id="startAnthropicValidation" class="btn btn-warning">
                  <span>üîç</span>
                  Validate with Anthropic
                </button>
              </div>
            </div>
          </div>
          <div class="step-actions" style="margin-top: 20px">
            <button id="downloadScoresAlways" class="btn btn-success" disabled>
              <span>üì•</span>
              Download OpenAI Scores
            </button>
          </div>
          
          <!-- Anthropic Validation Section (appears after OpenAI completion) -->
          <div id="anthropicValidationSection" class="evaluation-progress hidden" style="margin-top: 20px;">
            <div class="eval-header">
              <h4>üîç Anthropic Validation in Progress...</h4>
              <div class="eval-counter">
                <span id="validatedCount">0</span> /
                <span id="totalToValidate">0</span> files validated
              </div>
            </div>
            <div class="progress-bar">
              <div
                id="validationProgressFill"
                class="progress-fill"
                style="width: 0%"
              ></div>
            </div>
            <div class="eval-stats">
              <div class="stat-item">
                <span class="stat-label">Valid:</span>
                <span id="validationValid" class="stat-value">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Invalid:</span>
                <span id="validationInvalid" class="stat-value">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Agreement:</span>
                <span id="agreementRate" class="stat-value">-</span>
              </div>
            </div>
          </div>
          
          <!-- Anthropic Validation Complete -->
          <div id="anthropicValidationComplete" class="evaluation-complete hidden" style="margin-top: 20px;">
            <div class="complete-header">
              <h4>‚úÖ Anthropic Validation Complete!</h4>
              <div class="complete-summary">
                <span id="anthropicValidationSummary">0 files validated successfully</span>
              </div>
            </div>
            <button id="downloadValidations" class="btn btn-success">
              <span>üì•</span>
              Download Validations
            </button>
          </div>
        </div>

        <!-- Step 5: Anthropic Validation - COMMENTED OUT FOR OPENAI-ONLY MODE -->
        <!-- 
        <div class="step-card status-pending" id="step5">
          <div class="step-header">
            <div class="step-number">5</div>
            <div class="step-title">Anthropic Validation</div>
          </div>
          <div class="step-content">
            <div class="step-description">
              Second-opinion validation using Anthropic Claude for quality
              assurance.
            </div>

            <!-- Validation Progress -->
            <div id="validationProgress" class="evaluation-progress hidden">
              <div class="eval-header">
                <h4>üîç Anthropic Validation in Progress...</h4>
                <div class="eval-counter">
                  <span id="validatedCount">0</span> /
                  <span id="totalToValidate">0</span> files validated
                </div>
              </div>
              <div class="progress-bar">
                <div
                  id="validationProgressFill"
                  class="progress-fill"
                  style="width: 0%"
                ></div>
              </div>
              <div class="eval-stats">
                <div class="stat-item">
                  <span class="stat-label">Valid:</span>
                  <span id="validationValid" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Invalid:</span>
                  <span id="validationInvalid" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Agreement:</span>
                  <span id="agreementRate" class="stat-value">-</span>
                </div>
              </div>
            </div>

            <!-- Validation Complete -->
            <div id="validationComplete" class="evaluation-complete hidden">
              <div class="complete-header">
                <h4>‚úÖ Anthropic Validation Complete!</h4>
                <div class="complete-summary">
                  <span id="validationSummary"
                    >0 files validated successfully</span
                  >
                </div>
              </div>
              <button id="downloadValidations" class="btn">
                <span>üì•</span>
                Download Validations
              </button>
            </div>
          </div>
          <div class="step-actions" style="margin-top: 20px">
            <button
              id="downloadValidationsAlways"
              class="btn btn-success"
              disabled
            >
              <span>üì•</span>
              Download Anthropic Validations
            </button>
          </div>
        </div>
        -->
      </div>

      <!-- Progress Monitoring Section -->
      <div class="progress-section" id="progressSection">
        <div class="progress-header">
          <div class="progress-title">üìä Processing Progress</div>
          <div>
            Batch ID: <span id="progressBatchId" class="batch-id">None</span>
          </div>
        </div>

        <div class="metrics-grid">
          <div class="metric-card">
            <div id="totalFiles" class="metric-value">0</div>
            <div class="metric-label">Total Files</div>
          </div>
          <div class="metric-card">
            <div id="extractedFiles" class="metric-value">0</div>
            <div class="metric-label">Extracted</div>
          </div>
          <div class="metric-card">
            <div id="scoredFiles" class="metric-value">0</div>
            <div class="metric-label">Scored</div>
          </div>
          <div class="metric-card">
            <div id="validatedFiles" class="metric-value">0</div>
            <div class="metric-label">Validated</div>
          </div>
          <div class="metric-card">
            <div id="completedFiles" class="metric-value">0</div>
            <div class="metric-label">Completed</div>
          </div>
          <div class="metric-card">
            <div id="failedFiles" class="metric-value">0</div>
            <div class="metric-label">Failed</div>
          </div>
          <div class="metric-card">
            <div id="throughput" class="metric-value">0</div>
            <div class="metric-label">Files/Hour</div>
          </div>
          <div class="metric-card">
            <div id="elapsedTime" class="metric-value">00:00:00</div>
            <div class="metric-label">Elapsed Time</div>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">Overall Progress</label>
          <div class="progress-bar">
            <div
              id="overallProgress"
              class="progress-fill"
              style="width: 0%"
            ></div>
          </div>
          <div id="progressText">0 / 0 files processed</div>
        </div>

        <div class="form-group">
          <label class="form-label">Success Rate</label>
          <div class="progress-bar">
            <div
              id="successProgress"
              class="progress-fill success"
              style="width: 0%"
            ></div>
          </div>
          <div id="successText">0 / 0 successful</div>
        </div>

        <!-- Status Log -->
        <div class="form-group">
          <label class="form-label">System Status</label>
          <div id="statusLog" class="status-log">
            <div class="log-entry info">
              System ready - upload resumes to begin...
            </div>
          </div>
        </div>
      </div>

      <!-- Results Section -->
      <div class="results-section" id="resultsSection">
        <div class="results-title">üéâ Processing Complete!</div>
        <div class="results-description">
          All resumes have been processed through the complete pipeline.
          Download your results below.
        </div>
        <div class="results-buttons">
          <button id="downloadExtractions" class="btn">
            <span>üìÑ</span>
            Download Extractions
          </button>
          <button id="downloadScores" class="btn btn-success">
            <span>üéØ</span>
            Download Scores
          </button>
          <button id="downloadValidations" class="btn">
            <span>‚úÖ</span>
            Download Validations
          </button>
          <button id="downloadReport" class="btn">
            <span>üìä</span>
            Download Report
          </button>
        </div>
      </div>
    </div>

    <script>
      class ResumeProcessor {
        constructor() {
          this.apiBaseUrl = this.detectApiBaseUrl();
          this.currentBatchId = null;
          this.files = [];
          this.extracted = false;
          this.configured = false;
          this.batchCreated = false;
          this.progressInterval = null;

          // Conversion tracking
          this.conversionStartTime = null;
          this.conversionProgressInterval = null;

          this.initializeEventListeners();
          this.loadExtractionMode();
          this.addLog(
            "System initialized - ready for resume processing",
            "info"
          );
          this.checkServerConnection();
        }

        detectApiBaseUrl() {
          const currentOrigin = window.location.origin;
          if (
            currentOrigin.includes("127.0.0.1:5500") ||
            currentOrigin.includes("file://") ||
            currentOrigin.includes("localhost:5500")
          ) {
            return "http://localhost:3000";
          } else {
            return currentOrigin;
          }
        }

        async checkServerConnection() {
          try {
            const response = await fetch(`${this.apiBaseUrl}/api/health`);
            if (response.ok) {
              this.addLog("‚úÖ Connected to server successfully", "success");
              this.addLog(
                "ü§ñ AI Services: LlamaIndex + OpenAI + Anthropic",
                "info"
              );
            } else {
              throw new Error(
                `Server responded with status ${response.status}`
              );
            }
          } catch (error) {
            this.addLog(
              `‚ùå Cannot connect to server at ${this.apiBaseUrl}`,
              "error"
            );
            this.addLog(
              "Please ensure the Node.js server is running on port 3000",
              "warning"
            );
          }
        }

        initializeEventListeners() {
          // File upload
          const fileUploadArea = document.getElementById("fileUploadArea");
          const fileInput = document.getElementById("fileInput");

          fileUploadArea.addEventListener("click", () => fileInput.click());
          fileUploadArea.addEventListener(
            "dragover",
            this.handleDragOver.bind(this)
          );
          fileUploadArea.addEventListener(
            "dragleave",
            this.handleDragLeave.bind(this)
          );
          fileUploadArea.addEventListener("drop", this.handleDrop.bind(this));
          fileInput.addEventListener(
            "change",
            this.handleFileSelect.bind(this)
          );

          // Step buttons
          document
            .getElementById("convertToJson")
            .addEventListener("click", this.convertToJson.bind(this));
          document
            .getElementById("saveConfig")
            .addEventListener("click", this.saveConfiguration.bind(this));
          document
            .getElementById("startEvaluation")
            .addEventListener("click", this.startEvaluation.bind(this));

          // Download buttons
          document
            .getElementById("downloadExtractions")
            .addEventListener("click", () =>
              this.downloadResults("extractions")
            );
          document
            .getElementById("downloadScores")
            .addEventListener("click", () => this.downloadResults("scores"));
          document
            .getElementById("downloadValidations")
            .addEventListener("click", () =>
              this.downloadResults("validations")
            );

          // Always-available download buttons
          document
            .getElementById("downloadExtractionsAlways")
            .addEventListener("click", () =>
              this.downloadResults("extractions")
            );
          document
            .getElementById("downloadScoresAlways")
            .addEventListener("click", () => this.downloadResults("scores"));
          
          // Anthropic validation button (commented out - not using for now)
          // document
          //   .getElementById("downloadValidationsAlways")
          //   .addEventListener("click", () =>
          //     this.downloadResults("validations")
          //   );
          
          // New Anthropic validation starter
          document
            .getElementById("startAnthropicValidation")
            .addEventListener("click", this.startAnthropicValidation.bind(this));
            
          // Extraction mode switcher
          document
            .getElementById("extractionMode")
            .addEventListener("change", this.switchExtractionMode.bind(this));

          // Configuration fields
          document
            .getElementById("jobDescription")
            .addEventListener("input", this.validateConfiguration.bind(this));
          document
            .getElementById("evaluationRubric")
            .addEventListener("input", this.validateConfiguration.bind(this));
        }

        handleDragOver(e) {
          e.preventDefault();
          document.getElementById("fileUploadArea").classList.add("dragover");
        }

        handleDragLeave(e) {
          e.preventDefault();
          document
            .getElementById("fileUploadArea")
            .classList.remove("dragover");
        }

        handleDrop(e) {
          e.preventDefault();
          document
            .getElementById("fileUploadArea")
            .classList.remove("dragover");
          const files = Array.from(e.dataTransfer.files).filter(
            (file) =>
              file.type === "application/pdf" ||
              file.name.toLowerCase().endsWith(".pdf")
          );
          this.updateFiles(files);
        }

        handleFileSelect(e) {
          const files = Array.from(e.target.files);
          this.updateFiles(files);
        }

        updateFiles(files) {
          this.files = files;
          this.displayFileList();
          this.updateStepStatus();

          if (files.length > 0) {
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            this.addLog(
              `Selected ${files.length} PDF files (${this.formatFileSize(
                totalSize
              )} total)`,
              "info"
            );

            if (files.length > 1000) {
              this.addLog(
                `Large batch detected (${files.length} files) - processing will be optimized`,
                "warning"
              );
            }

            document.getElementById("step1").classList.add("status-active");
          }
        }

        displayFileList() {
          const fileList = document.getElementById("fileList");

          if (this.files.length === 0) {
            fileList.classList.add("hidden");
            return;
          }

          fileList.classList.remove("hidden");

          if (this.files.length > 20) {
            // Show summary for large batches
            const totalSize = this.files.reduce(
              (sum, file) => sum + file.size,
              0
            );
            fileList.innerHTML = `
                        <div class="file-item">
                            <span class="file-name">üìä ${
                              this.files.length
                            } PDF files selected</span>
                            <span class="file-size">${this.formatFileSize(
                              totalSize
                            )}</span>
                        </div>
                        <div class="file-item">
                            <span class="file-name">Average size: ${this.formatFileSize(
                              totalSize / this.files.length
                            )}</span>
                            <span class="file-size">Ready for processing</span>
                        </div>
                    `;
          } else {
            // Show individual files for small batches
            fileList.innerHTML = this.files
              .map(
                (file) => `
                        <div class="file-item">
                            <span class="file-name">${file.name}</span>
                            <span class="file-size">${this.formatFileSize(
                              file.size
                            )}</span>
                        </div>
                    `
              )
              .join("");
          }
        }

        async convertToJson() {
          if (this.files.length === 0) {
            this.addLog("No files selected for conversion", "error");
            return;
          }

          try {
            const formData = new FormData();
            this.files.forEach((file) => {
              formData.append("resumes", file);
            });

            // Show conversion progress
            this.showConversionProgress();

            this.addLog(
              `üîÑ Converting ${this.files.length} resumes to JSON using LlamaIndex...`,
              "info"
            );
            this.addLog(
              `‚ö†Ô∏è Processing with rate limiting - this will take time`,
              "warning"
            );

            // Update button state
            const convertBtn = document.getElementById("convertToJson");
            convertBtn.disabled = true;
            convertBtn.classList.add("converting");
            convertBtn.innerHTML = "<span>üîÑ</span> Converting...";

            // Start progress monitoring
            this.startConversionMonitoring();

            const response = await fetch(`${this.apiBaseUrl}/api/extract`, {
              method: "POST",
              body: formData,
            });

            const result = await response.json();

            if (result.success) {
              this.currentBatchId = result.data.batchId;
              this.extracted = true;

              // Final update
              this.updateConversionProgress(
                result.data.extractedCount,
                this.files.length,
                result.data.extractedCount,
                0
              );

              // Show extraction complete section
              this.showExtractionComplete(result.data.extractedCount);

              this.addLog(
                `‚úÖ Successfully extracted ${result.data.extractedCount} resumes`,
                "success"
              );
              this.addLog(`Batch ID: ${this.currentBatchId}`, "info");

              document
                .getElementById("step1")
                .classList.remove("status-active");
              document.getElementById("step1").classList.add("completed");
              document.getElementById("step2").classList.add("status-active");

              this.updateStepStatus();
              this.stopConversionMonitoring();
            } else {
              this.addLog(`Extraction failed: ${result.error}`, "error");
              this.stopConversionMonitoring();
            }
          } catch (error) {
            this.addLog(`Extraction error: ${error.message}`, "error");
            this.stopConversionMonitoring();
          } finally {
            const convertBtn = document.getElementById("convertToJson");
            convertBtn.disabled = false;
            convertBtn.classList.remove("converting");
            convertBtn.innerHTML = "<span>üîÑ</span> Convert to JSON";
          }
        }

        showConversionProgress() {
          const progressDiv = document.getElementById("conversionProgress");
          progressDiv.classList.remove("hidden");

          // Initialize counters
          document.getElementById("totalToConvert").textContent =
            this.files.length;
          document.getElementById("convertedCount").textContent = "0";
          document.getElementById("conversionSuccess").textContent = "0";
          document.getElementById("conversionFailed").textContent = "0";
          document.getElementById("conversionRate").textContent = "0/min";
          document.getElementById("conversionProgressFill").style.width = "0%";

          this.conversionStartTime = Date.now();
        }

        startConversionMonitoring() {
          // Monitor conversion progress every 3 seconds
          this.conversionProgressInterval = setInterval(async () => {
            if (this.currentBatchId) {
              await this.updateConversionStatus();
            }
          }, 3000);
        }

        stopConversionMonitoring() {
          if (this.conversionProgressInterval) {
            clearInterval(this.conversionProgressInterval);
            this.conversionProgressInterval = null;
          }
        }

        async updateConversionStatus() {
          try {
            if (!this.currentBatchId) return;

            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/progress`
            );
            if (!response.ok) return;

            const result = await response.json();
            if (!result.success) return;

            const metrics = result.data.metrics;
            const completed = metrics.completed || metrics.extracted || 0;
            const failed = metrics.failed || 0;
            const total = metrics.total || this.files.length;

            this.updateConversionProgress(
              completed + failed,
              total,
              completed,
              failed
            );
          } catch (error) {
            console.warn("Error updating conversion status:", error);
          }
        }

        updateConversionProgress(processed, total, success, failed) {
          // Update counters
          document.getElementById("convertedCount").textContent = processed;
          document.getElementById("totalToConvert").textContent = total;
          document.getElementById("conversionSuccess").textContent = success;
          document.getElementById("conversionFailed").textContent = failed;

          // Update progress bar
          const percentage = total > 0 ? (processed / total) * 100 : 0;
          document.getElementById("conversionProgressFill").style.width =
            percentage + "%";

          // Calculate and display rate
          if (this.conversionStartTime && processed > 0) {
            const elapsedMinutes =
              (Date.now() - this.conversionStartTime) / (1000 * 60);
            const rate =
              elapsedMinutes > 0 ? Math.round(processed / elapsedMinutes) : 0;
            document.getElementById("conversionRate").textContent =
              rate + "/min";
          }

          // Update log with progress
          if (processed > 0) {
            this.addLog(
              `üìä Conversion progress: ${processed}/${total} files (${Math.round(
                percentage
              )}%) - ${success} success, ${failed} failed`,
              "info"
            );
          }
        }

        showExtractionComplete(extractedCount) {
          const extractionComplete =
            document.getElementById("extractionComplete");
          const extractedSummary = document.getElementById("extractedSummary");
          const conversionProgress =
            document.getElementById("conversionProgress");

          if (extractionComplete) {
            extractionComplete.classList.remove("hidden");
          }
          if (extractedSummary) {
            extractedSummary.textContent = `${extractedCount} files extracted successfully`;
          }
          if (conversionProgress) {
            conversionProgress.classList.add("hidden");
          }

          // Enable the always-available download button
          const downloadExtractionsBtn = document.getElementById(
            "downloadExtractionsAlways"
          );
          if (downloadExtractionsBtn) {
            downloadExtractionsBtn.disabled = false;
          }
        }

        validateConfiguration() {
          const jobDesc = document
            .getElementById("jobDescription")
            .value.trim();
          const rubric = document
            .getElementById("evaluationRubric")
            .value.trim();

          const isValid = jobDesc.length >= 20 && rubric.length >= 20;
          document.getElementById("saveConfig").disabled = !isValid;

          return isValid;
        }

        async saveConfiguration() {
          if (!this.validateConfiguration()) {
            this.addLog(
              "Job description and rubric must be at least 20 characters each",
              "error"
            );
            return;
          }

          const jobDescription = document
            .getElementById("jobDescription")
            .value.trim();
          const evaluationRubric = document
            .getElementById("evaluationRubric")
            .value.trim();

          try {
            this.addLog("üíæ Saving job configuration...", "info");

            const response = await fetch(`${this.apiBaseUrl}/api/config`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ jobDescription, evaluationRubric }),
            });

            const result = await response.json();

            if (result.success) {
              this.configured = true;
              this.addLog("‚úÖ Configuration saved successfully", "success");

              document
                .getElementById("step2")
                .classList.remove("status-active");
              document.getElementById("step2").classList.add("completed");
              document.getElementById("step3").classList.add("status-active");

              // Auto-detect extracted files for Step 3
              await this.detectExtractedFiles();

              this.updateStepStatus();
            } else {
              this.addLog(`Configuration error: ${result.error}`, "error");
            }
          } catch (error) {
            this.addLog(`Configuration save error: ${error.message}`, "error");
          }
        }

        async detectExtractedFiles() {
          try {
            // Auto-detect extracted JSON files
            const response = await fetch(
              `${this.apiBaseUrl}/api/extracted-files`
            );
            const result = await response.json();

            if (result.success && result.data.files.length > 0) {
              this.showDetectedFiles(result.data.files);
              this.showReadyToStart(result.data.files.length);
            } else {
              this.addLog(
                "‚ö†Ô∏è No extracted JSON files found. Please complete Step 1 first.",
                "warning"
              );
            }
          } catch (error) {
            this.addLog(`Error detecting files: ${error.message}`, "error");
          }
        }

        showDetectedFiles(files) {
          const detectedDiv = document.getElementById("detectedFiles");
          const filesList = document.getElementById("detectedFilesList");

          if (!detectedDiv || !filesList) return; // Defensive check

          detectedDiv.classList.remove("hidden");
          document.getElementById("detectedCount").textContent = files.length;

          // Show first 10 files with option to expand
          const displayFiles = files.slice(0, 10);
          filesList.innerHTML = displayFiles
            .map(
              (file) => `
                    <div class="detected-item">
                        <span class="detected-name">${file.name}</span>
                        <span class="detected-size">${this.formatFileSize(
                          file.size
                        )}</span>
                    </div>
                `
            )
            .join("");

          if (files.length > 10) {
            filesList.innerHTML += `
                        <div class="detected-item">
                            <span class="detected-name">... and ${
                              files.length - 10
                            } more files</span>
                            <span class="detected-size">Ready for evaluation</span>
                        </div>
                    `;
          }
        }

        showReadyToStart(fileCount) {
          const readyDiv = document.getElementById("readyToStart");
          if (!readyDiv) return; // Defensive check

          readyDiv.classList.remove("hidden");

          document.getElementById("readyExtracted").textContent = fileCount;
          document.getElementById("readyConfig").textContent = this.configured
            ? "Configured ‚úÖ"
            : "Not set";
          document.getElementById("readyToEvaluate").textContent = fileCount;

          // Enable start button if both extraction and config are ready
          document.getElementById("startEvaluation").disabled = !(
            fileCount > 0 && this.configured
          );
        }

                    async startEvaluation() {
            try {
              this.addLog("üöÄ Starting OpenAI scoring pipeline...", "info");
              this.addLog(
                "Creating automatic batch and beginning OpenAI evaluation...",
                "info"
              );

              // Auto-create batch and start OpenAI scoring only
              const response = await fetch(
                `${this.apiBaseUrl}/api/start-evaluation`,
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                }
              );

              const result = await response.json();

              if (result.success) {
                this.currentBatchId = result.data.batchId;
                this.addLog(
                  `‚úÖ OpenAI scoring started - Batch ID: ${this.currentBatchId}`,
                  "success"
                );

                document
                  .getElementById("step3")
                  .classList.remove("status-active");
                document.getElementById("step3").classList.add("completed");
                document.getElementById("step4").classList.add("processing");

                // Start monitoring OpenAI scoring only
                this.startScoringMonitoring();

                this.updateStepStatus();
              } else {
                this.addLog(`OpenAI scoring start failed: ${result.error}`, "error");
              }
            } catch (error) {
              this.addLog(`OpenAI scoring start error: ${error.message}`, "error");
            }
          }

          async startAnthropicValidation() {
            try {
              if (!this.currentBatchId) {
                this.addLog("No batch ID available. Please complete OpenAI scoring first.", "error");
                return;
              }

              this.addLog("üîç Starting Anthropic validation...", "info");
              this.addLog("Validating OpenAI scores with Claude...", "info");

              const response = await fetch(
                `${this.apiBaseUrl}/api/start-anthropic-validation`,
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ batchId: this.currentBatchId })
                }
              );

              const result = await response.json();

              if (result.success) {
                this.addLog(
                  `‚úÖ Anthropic validation started for batch ${this.currentBatchId}`,
                  "success"
                );

                // Hide the start button and show progress
                document.getElementById("startAnthropicValidation").style.display = "none";
                document.getElementById("anthropicValidationSection").classList.remove("hidden");

                // Start monitoring validation progress
                this.startValidationMonitoring();

              } else {
                this.addLog(`Anthropic validation start failed: ${result.error}`, "error");
              }
            } catch (error) {
              this.addLog(`Anthropic validation start error: ${error.message}`, "error");
            }
          }

                  startScoringMonitoring() {
            // Show OpenAI scoring progress only
            const scoringProgress = document.getElementById("scoringProgress");
            if (scoringProgress) scoringProgress.classList.remove("hidden");

            // Start monitoring OpenAI progress every 3 seconds
            this.progressInterval = setInterval(async () => {
              await this.updateScoringProgress();
            }, 3000);
          }

          startValidationMonitoring() {
            // Start monitoring Anthropic validation progress every 3 seconds
            this.validationInterval = setInterval(async () => {
              await this.updateValidationProgress();
            }, 3000);
          }

                  async updateScoringProgress() {
            try {
              if (!this.currentBatchId) return;

              const response = await fetch(
                `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/progress`
              );
              const result = await response.json();

              if (result.success) {
                const metrics = result.data.metrics;

                // Update scoring progress display
                this.updateScoringProgressDisplay(metrics);

                // Check if scoring is completed
                if (result.data.status === "scored") {
                  this.handleScoringComplete(metrics);
                }
              }
            } catch (error) {
              console.warn("Error updating scoring progress:", error);
            }
          }

          async updateValidationProgress() {
            try {
              if (!this.currentBatchId) return;

              const response = await fetch(
                `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/progress`
              );
              const result = await response.json();

              if (result.success) {
                const metrics = result.data.metrics;

                // Update validation progress display
                this.updateValidationProgressDisplay(metrics);

                // Check if validation is completed
                if (result.data.status === "completed") {
                  this.handleValidationComplete(metrics);
                }
              }
            } catch (error) {
              console.warn("Error updating validation progress:", error);
            }
          }

                  updateScoringProgressDisplay(metrics) {
          const scored = metrics.scored || 0;
          const total = metrics.total || 0;
          const failed = metrics.failed || 0;

          const elements = {
            scoredCount: document.getElementById("scoredCount"),
            totalToScore: document.getElementById("totalToScore"),
            scoringCompleted: document.getElementById("scoringCompleted"),
            scoringFailed: document.getElementById("scoringFailed"),
            scoringProgressFill: document.getElementById("scoringProgressFill"),
            avgScore: document.getElementById("avgScore"),
          };

          // Update elements if they exist
          if (elements.scoredCount) elements.scoredCount.textContent = scored;
          if (elements.totalToScore) elements.totalToScore.textContent = total;
          if (elements.scoringCompleted)
            elements.scoringCompleted.textContent = scored;
          if (elements.scoringFailed)
            elements.scoringFailed.textContent = failed;

          const percentage = total > 0 ? (scored / total) * 100 : 0;
          if (elements.scoringProgressFill) {
            elements.scoringProgressFill.style.width = percentage + "%";
          }

          // Show average score if available
          if (scored > 0 && elements.avgScore) {
            elements.avgScore.textContent = "75/150"; // Placeholder
          }

                          // Scoring completion is now handled separately
                // This just updates the progress display
        }

                  updateValidationProgressDisplay(metrics) {
          const validated = metrics.completed || 0;
          const total = metrics.total || 0;

          const elements = {
            validatedCount: document.getElementById("validatedCount"),
            totalToValidate: document.getElementById("totalToValidate"),
            validationValid: document.getElementById("validationValid"),
            validationInvalid: document.getElementById("validationInvalid"),
            validationProgressFill: document.getElementById(
              "validationProgressFill"
            ),
            agreementRate: document.getElementById("agreementRate"),
          };

          // Update elements if they exist
          if (elements.validatedCount)
            elements.validatedCount.textContent = validated;
          if (elements.totalToValidate)
            elements.totalToValidate.textContent = total;
          if (elements.validationValid)
            elements.validationValid.textContent = validated;
          if (elements.validationInvalid)
            elements.validationInvalid.textContent = "0"; // Placeholder

          const percentage = total > 0 ? (validated / total) * 100 : 0;
          if (elements.validationProgressFill) {
            elements.validationProgressFill.style.width = percentage + "%";
          }

          // Show agreement rate if available
          if (validated > 0 && elements.agreementRate) {
            elements.agreementRate.textContent = "85%"; // Placeholder
          }

                          // Validation completion is now handled separately
                // This just updates the progress display
        }

                  handleScoringComplete(metrics) {
            this.stopScoringMonitoring();

            const scored = metrics.scored || 0;
            const total = metrics.total || 0;
            const successRate = ((scored / total) * 100).toFixed(1);
            
            this.addLog(
              `üéâ OpenAI scoring completed! ${scored}/${total} files scored (${successRate}%)`,
              "success"
            );
            this.addLog(`üìä OpenAI scores ready for download`, "info");
            this.addLog(`üîç Click 'Validate with Anthropic' to continue with validation`, "info");

            // Hide progress, show completion with validation button
            const scoringProgress = document.getElementById("scoringProgress");
            const scoringComplete = document.getElementById("scoringComplete");
            const scoringSummary = document.getElementById("scoringSummary");

            if (scoringProgress) scoringProgress.classList.add("hidden");
            if (scoringComplete) scoringComplete.classList.remove("hidden");
            if (scoringSummary) scoringSummary.textContent = `${scored} files scored successfully`;

            document.getElementById("step4").classList.remove("processing");
            document.getElementById("step4").classList.add("completed");
          }

          handleValidationComplete(metrics) {
            this.stopValidationMonitoring();

            const validated = metrics.completed || 0;
            const total = metrics.total || 0;
            const successRate = ((validated / total) * 100).toFixed(1);
            
            this.addLog(
              `üéâ Anthropic validation completed! ${validated}/${total} files validated (${successRate}%)`,
              "success"
            );
            this.addLog(`üìä Validation results ready for download`, "info");

            // Hide progress, show completion
            const validationSection = document.getElementById("anthropicValidationSection");
            const validationComplete = document.getElementById("anthropicValidationComplete");
            const validationSummary = document.getElementById("anthropicValidationSummary");

            if (validationSection) validationSection.classList.add("hidden");
            if (validationComplete) validationComplete.classList.remove("hidden");
            if (validationSummary) validationSummary.textContent = `${validated} files validated successfully`;
          }

          stopScoringMonitoring() {
            if (this.progressInterval) {
              clearInterval(this.progressInterval);
              this.progressInterval = null;
            }
          }

          stopValidationMonitoring() {
            if (this.validationInterval) {
              clearInterval(this.validationInterval);
              this.validationInterval = null;
            }
          }

          // Load current extraction mode
          async loadExtractionMode() {
            try {
              const response = await fetch(`${this.apiBaseUrl}/api/extraction-mode`);
              const result = await response.json();
              
              if (result.success) {
                const modeSelect = document.getElementById("extractionMode");
                const statusSpan = document.getElementById("extractionModeStatus");
                
                if (modeSelect) {
                  modeSelect.value = result.data.mode;
                }
                
                if (statusSpan) {
                  statusSpan.textContent = `üìÅ ${result.data.extractionDir}`;
                  statusSpan.style.color = "#28a745";
                }
                
                this.addLog(`Extraction mode: ${result.data.mode} (${result.data.extractionDir})`, "info");
              }
            } catch (error) {
              console.warn("Failed to load extraction mode:", error);
            }
          }

          // Switch extraction mode
          async switchExtractionMode(event) {
            try {
              const mode = event.target.value;
              const statusSpan = document.getElementById("extractionModeStatus");
              
              if (statusSpan) {
                statusSpan.textContent = "üîÑ Switching...";
                statusSpan.style.color = "#ffc107";
              }
              
              const response = await fetch(`${this.apiBaseUrl}/api/extraction-mode`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ mode })
              });
              
              const result = await response.json();
              
              if (result.success) {
                if (statusSpan) {
                  statusSpan.textContent = `üìÅ ${result.data.extractionDir}`;
                  statusSpan.style.color = "#28a745";
                }
                
                this.addLog(`‚úÖ Switched to ${mode} mode: ${result.data.extractionDir}`, "success");
                
                // Reset extraction status to force re-detection
                this.extracted = false;
                this.detectExtractedFiles();
              } else {
                if (statusSpan) {
                  statusSpan.textContent = "‚ùå Failed";
                  statusSpan.style.color = "#dc3545";
                }
                
                this.addLog(`Failed to switch extraction mode: ${result.error}`, "error");
              }
            } catch (error) {
              const statusSpan = document.getElementById("extractionModeStatus");
              if (statusSpan) {
                statusSpan.textContent = "‚ùå Error";
                statusSpan.style.color = "#dc3545";
              }
              
              this.addLog(`Error switching extraction mode: ${error.message}`, "error");
            }
          }

        async createBatch() {
          if (!this.extracted || !this.configured) {
            this.addLog("Complete extraction and configuration first", "error");
            return;
          }

          try {
            this.addLog("üì¶ Creating processing batch...", "info");

            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/prepare`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
              }
            );

            const result = await response.json();

            if (result.success) {
              this.batchCreated = true;
              this.addLog("‚úÖ Batch created successfully", "success");
              this.addLog(
                `Ready to process ${result.data.totalFiles} files`,
                "info"
              );

              document
                .getElementById("step3")
                .classList.remove("status-active");
              document
                .getElementById("step3")
                .classList.add("status-completed");
              document.getElementById("step4").classList.add("status-active");

              document.getElementById("currentBatchId").textContent =
                this.currentBatchId;
              document
                .getElementById("pipelineInfo")
                .classList.remove("hidden");

              this.updateStepStatus();
            } else {
              this.addLog(`Batch creation failed: ${result.error}`, "error");
            }
          } catch (error) {
            this.addLog(`Batch creation error: ${error.message}`, "error");
          }
        }

        async startProcessing() {
          if (!this.batchCreated) {
            this.addLog("Create a batch first", "error");
            return;
          }

          try {
            this.addLog("üöÄ Starting 3-stage processing pipeline...", "info");
            this.addLog(
              "Stage 1: OpenAI Scoring | Stage 2: Anthropic Validation",
              "info"
            );

            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/start`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
              }
            );

            const result = await response.json();

            if (result.success) {
              this.addLog("‚úÖ Processing started successfully", "success");

              document
                .getElementById("step4")
                .classList.remove("status-active");
              document
                .getElementById("step4")
                .classList.add("status-completed");

              this.showProgressSection();
              this.updateControlButtons("running");
              this.startProgressPolling();
            } else {
              this.addLog(`Processing start failed: ${result.error}`, "error");
            }
          } catch (error) {
            this.addLog(`Processing start error: ${error.message}`, "error");
          }
        }

        async pauseProcessing() {
          await this.sendBatchCommand("pause");
        }

        async resumeProcessing() {
          await this.sendBatchCommand("resume");
        }

        async cancelProcessing() {
          if (
            confirm(
              "Are you sure you want to cancel processing? This cannot be undone."
            )
          ) {
            await this.sendBatchCommand("cancel");
          }
        }

        async sendBatchCommand(command) {
          try {
            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/${command}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
              }
            );

            const result = await response.json();

            if (result.success) {
              this.addLog(`‚úÖ Batch ${command}ed successfully`, "info");
              this.updateControlButtons(result.data.status);

              if (command === "cancel") {
                this.stopProgressPolling();
              }
            } else {
              this.addLog(`${command} failed: ${result.error}`, "error");
            }
          } catch (error) {
            this.addLog(`${command} error: ${error.message}`, "error");
          }
        }

        showProgressSection() {
          document.getElementById("progressSection").style.display = "block";
          document.getElementById("progressBatchId").textContent =
            this.currentBatchId;
          document
            .getElementById("progressSection")
            .scrollIntoView({ behavior: "smooth" });
        }

        updateControlButtons(status) {
          const buttons = {
            start: document.getElementById("startProcessing"),
            pause: document.getElementById("pauseProcessing"),
            resume: document.getElementById("resumeProcessing"),
            cancel: document.getElementById("cancelProcessing"),
          };

          // Hide all control buttons
          Object.values(buttons).forEach((btn) => btn.classList.add("hidden"));

          // Show appropriate buttons based on status
          if (status === "processing" || status === "running") {
            buttons.pause.classList.remove("hidden");
            buttons.cancel.classList.remove("hidden");
          } else if (status === "paused") {
            buttons.resume.classList.remove("hidden");
            buttons.cancel.classList.remove("hidden");
          } else if (status === "completed") {
            // All buttons hidden for completed state
          } else {
            buttons.start.classList.remove("hidden");
          }
        }

        startProgressPolling() {
          this.progressInterval = setInterval(async () => {
            await this.updateProgress();
          }, 3000); // Every 3 seconds
        }

        stopProgressPolling() {
          if (this.progressInterval) {
            clearInterval(this.progressInterval);
            this.progressInterval = null;
          }
        }

        async updateProgress() {
          if (!this.currentBatchId) return;

          try {
            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/progress`
            );
            const result = await response.json();

            if (result.success) {
              this.updateProgressDisplay(result.data);

              if (result.data.status === "completed") {
                this.handleProcessingComplete(result.data);
              }
            }
          } catch (error) {
            console.error("Progress update error:", error);
          }
        }

        updateProgressDisplay(data) {
          const { metrics } = data;

          // Update metric cards
          document.getElementById("totalFiles").textContent = metrics.total;
          document.getElementById("extractedFiles").textContent =
            metrics.extracted;
          document.getElementById("scoredFiles").textContent = metrics.scored;
          document.getElementById("validatedFiles").textContent =
            metrics.validating + metrics.completed;
          document.getElementById("completedFiles").textContent =
            metrics.completed;
          document.getElementById("failedFiles").textContent = metrics.failed;
          document.getElementById("throughput").textContent = Math.round(
            metrics.timing.throughputPerHour
          );
          document.getElementById("elapsedTime").textContent =
            this.formatDuration(metrics.timing.elapsedMs);

          // Update progress bars
          const totalProcessed = metrics.completed + metrics.failed;
          const overallPercent = (totalProcessed / metrics.total) * 100;
          document.getElementById("overallProgress").style.width =
            overallPercent + "%";
          document.getElementById(
            "progressText"
          ).textContent = `${totalProcessed} / ${metrics.total} files processed`;

          const successPercent =
            totalProcessed > 0 ? (metrics.completed / totalProcessed) * 100 : 0;
          document.getElementById("successProgress").style.width =
            successPercent + "%";
          document.getElementById(
            "successText"
          ).textContent = `${metrics.completed} / ${totalProcessed} successful`;
        }

        handleProcessingComplete(data) {
          this.stopProgressPolling();
          this.updateControlButtons("completed");

          const successRate = (
            (data.metrics.completed / data.metrics.total) *
            100
          ).toFixed(1);
          this.addLog(
            `üéâ Processing completed! ${data.metrics.completed}/${data.metrics.total} successful (${successRate}%)`,
            "success"
          );

          document.getElementById("resultsSection").style.display = "block";
          document
            .getElementById("resultsSection")
            .scrollIntoView({ behavior: "smooth" });
        }

        async downloadResults(type) {
          if (!this.currentBatchId) {
            this.addLog("No batch available for download", "error");
            return;
          }

          try {
            this.addLog(`üì• Downloading ${type}...`, "info");

            const response = await fetch(
              `${this.apiBaseUrl}/api/batch/${this.currentBatchId}/download/${type}`
            );

            if (response.ok) {
              const blob = await response.blob();
              const url = window.URL.createObjectURL(blob);
              const link = document.createElement("a");
              link.href = url;

              const extension = type === "report" ? "json" : "zip";
              link.download = `batch-${this.currentBatchId}-${type}.${extension}`;

              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              window.URL.revokeObjectURL(url);

              this.addLog(`‚úÖ ${type} downloaded successfully`, "success");
            } else {
              const error = await response.json();
              this.addLog(`Download failed: ${error.error}`, "error");
            }
          } catch (error) {
            this.addLog(`Download error: ${error.message}`, "error");
          }
        }

        updateStepStatus() {
          // Update button states based on current progress
          const convertBtn = document.getElementById("convertToJson");
          const saveConfigBtn = document.getElementById("saveConfig");
          const startEvalBtn = document.getElementById("startEvaluation");

          if (convertBtn) {
            convertBtn.disabled = this.files.length === 0;
          }

          if (saveConfigBtn) {
            saveConfigBtn.disabled = !this.validateConfiguration();
          }

          // Step 3 button state
          const hasExtracted =
            this.extracted ||
            (document.getElementById("detectedCount") &&
              document.getElementById("detectedCount").textContent > "0");
          if (startEvalBtn) {
            startEvalBtn.disabled = !(hasExtracted && this.configured);
          }

          // Update always-available download buttons
          const downloadExtractionsBtn = document.getElementById(
            "downloadExtractionsAlways"
          );
          const downloadScoresBtn = document.getElementById(
            "downloadScoresAlways"
          );
          
          if (downloadExtractionsBtn) {
            downloadExtractionsBtn.disabled = !this.extracted;
          }
          
          if (downloadScoresBtn) {
            downloadScoresBtn.disabled = !this.currentBatchId;
          }
          
          // Anthropic validation button is now in Step 4 completion section
          // No need to manage it here
        }

        formatFileSize(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        formatDuration(ms) {
          if (ms < 0) return "--:--:--";

          const totalSeconds = Math.floor(ms / 1000);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;

          return `${hours.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        addLog(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");
          logEntry.className = `log-entry ${type}`;
          logEntry.textContent = `[${timestamp}] ${message}`;

          const statusLog = document.getElementById("statusLog");
          statusLog.appendChild(logEntry);
          statusLog.scrollTop = statusLog.scrollHeight;

          // Keep only last 100 entries
          const entries = statusLog.querySelectorAll(".log-entry");
          if (entries.length > 100) {
            entries[0].remove();
          }

          console.log(`[${type.toUpperCase()}] ${message}`);
        }
      }

      // Initialize the application
      const processor = new ResumeProcessor();
    </script>
  </body>
</html>
